{"ast":null,"code":"import encodeWAV from './waveEncoder';\nimport getUserMedia from './getUserMedia';\nimport AudioContext from './AudioContext';\n\nvar WAVEInterface =\n/** @class */\nfunction () {\n  function WAVEInterface() {\n    this.recordingNodes = [];\n  }\n\n  Object.defineProperty(WAVEInterface.prototype, \"bufferLength\", {\n    get: function () {\n      return this.buffers[0].length * WAVEInterface.bufferSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(WAVEInterface.prototype, \"audioDuration\", {\n    get: function () {\n      return this.bufferLength / WAVEInterface.audioContext.sampleRate;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(WAVEInterface.prototype, \"audioData\", {\n    get: function () {\n      return this.encodingCache || encodeWAV(this.buffers, this.bufferLength, WAVEInterface.audioContext.sampleRate);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  WAVEInterface.prototype.startRecording = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      getUserMedia({\n        audio: true\n      }, function (stream) {\n        var audioContext = WAVEInterface.audioContext;\n        var recGainNode = audioContext.createGain();\n        var recSourceNode = audioContext.createMediaStreamSource(stream);\n        var recProcessingNode = audioContext.createScriptProcessor(WAVEInterface.bufferSize, 2, 2);\n        if (_this.encodingCache) _this.encodingCache = null;\n\n        recProcessingNode.onaudioprocess = function (event) {\n          if (_this.encodingCache) _this.encodingCache = null; // save left and right buffers\n\n          for (var i = 0; i < 2; i++) {\n            var channel = event.inputBuffer.getChannelData(i);\n\n            _this.buffers[i].push(new Float32Array(channel));\n          }\n        };\n\n        recSourceNode.connect(recGainNode);\n        recGainNode.connect(recProcessingNode);\n        recProcessingNode.connect(audioContext.destination);\n        _this.recordingStream = stream;\n\n        _this.recordingNodes.push(recSourceNode, recGainNode, recProcessingNode);\n\n        resolve(stream);\n      }, function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  WAVEInterface.prototype.stopRecording = function () {\n    if (this.recordingStream) {\n      this.recordingStream.getTracks()[0].stop();\n      delete this.recordingStream;\n    }\n\n    for (var i in this.recordingNodes) {\n      this.recordingNodes[i].disconnect();\n      delete this.recordingNodes[i];\n    }\n  };\n\n  WAVEInterface.prototype.startPlayback = function (loop, onended) {\n    var _this = this;\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    return new Promise(function (resolve, reject) {\n      var reader = new FileReader();\n      reader.readAsArrayBuffer(_this.audioData);\n\n      reader.onloadend = function () {\n        WAVEInterface.audioContext.decodeAudioData(reader.result, function (buffer) {\n          var source = WAVEInterface.audioContext.createBufferSource();\n          source.buffer = buffer;\n          source.connect(WAVEInterface.audioContext.destination);\n          source.loop = loop;\n          source.start(0);\n          source.onended = onended;\n          _this.playbackNode = source;\n          resolve(source);\n        });\n      };\n    });\n  };\n\n  WAVEInterface.prototype.stopPlayback = function () {\n    this.playbackNode.stop();\n  };\n\n  WAVEInterface.prototype.reset = function () {\n    if (this.playbackNode) {\n      this.playbackNode.stop();\n      this.playbackNode.disconnect(0);\n      delete this.playbackNode;\n    }\n\n    this.stopRecording();\n    this.buffers = [[], []];\n  };\n\n  WAVEInterface.audioContext = new AudioContext();\n  WAVEInterface.bufferSize = 2048;\n  return WAVEInterface;\n}();\n\nexport default WAVEInterface;","map":{"version":3,"sources":["/Users/raunaqbahl/Documents/Uni/Sem 2, 2020/ENGG4802 (Thesis)/men-s-shed-thesis/mens-shed/node_modules/react-audio-recorder/dist/waveInterface.js"],"names":["encodeWAV","getUserMedia","AudioContext","WAVEInterface","recordingNodes","Object","defineProperty","prototype","get","buffers","length","bufferSize","enumerable","configurable","bufferLength","audioContext","sampleRate","encodingCache","startRecording","_this","Promise","resolve","reject","audio","stream","recGainNode","createGain","recSourceNode","createMediaStreamSource","recProcessingNode","createScriptProcessor","onaudioprocess","event","i","channel","inputBuffer","getChannelData","push","Float32Array","connect","destination","recordingStream","err","stopRecording","getTracks","stop","disconnect","startPlayback","loop","onended","reader","FileReader","readAsArrayBuffer","audioData","onloadend","decodeAudioData","result","buffer","source","createBufferSource","start","playbackNode","stopPlayback","reset"],"mappings":"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","sourcesContent":["import encodeWAV from './waveEncoder';\r\nimport getUserMedia from './getUserMedia';\r\nimport AudioContext from './AudioContext';\r\nvar WAVEInterface = /** @class */ (function () {\r\n    function WAVEInterface() {\r\n        this.recordingNodes = [];\r\n    }\r\n    Object.defineProperty(WAVEInterface.prototype, \"bufferLength\", {\r\n        get: function () { return this.buffers[0].length * WAVEInterface.bufferSize; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WAVEInterface.prototype, \"audioDuration\", {\r\n        get: function () { return this.bufferLength / WAVEInterface.audioContext.sampleRate; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WAVEInterface.prototype, \"audioData\", {\r\n        get: function () {\r\n            return this.encodingCache || encodeWAV(this.buffers, this.bufferLength, WAVEInterface.audioContext.sampleRate);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WAVEInterface.prototype.startRecording = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            getUserMedia({ audio: true }, function (stream) {\r\n                var audioContext = WAVEInterface.audioContext;\r\n                var recGainNode = audioContext.createGain();\r\n                var recSourceNode = audioContext.createMediaStreamSource(stream);\r\n                var recProcessingNode = audioContext.createScriptProcessor(WAVEInterface.bufferSize, 2, 2);\r\n                if (_this.encodingCache)\r\n                    _this.encodingCache = null;\r\n                recProcessingNode.onaudioprocess = function (event) {\r\n                    if (_this.encodingCache)\r\n                        _this.encodingCache = null;\r\n                    // save left and right buffers\r\n                    for (var i = 0; i < 2; i++) {\r\n                        var channel = event.inputBuffer.getChannelData(i);\r\n                        _this.buffers[i].push(new Float32Array(channel));\r\n                    }\r\n                };\r\n                recSourceNode.connect(recGainNode);\r\n                recGainNode.connect(recProcessingNode);\r\n                recProcessingNode.connect(audioContext.destination);\r\n                _this.recordingStream = stream;\r\n                _this.recordingNodes.push(recSourceNode, recGainNode, recProcessingNode);\r\n                resolve(stream);\r\n            }, function (err) {\r\n                reject(err);\r\n            });\r\n        });\r\n    };\r\n    WAVEInterface.prototype.stopRecording = function () {\r\n        if (this.recordingStream) {\r\n            this.recordingStream.getTracks()[0].stop();\r\n            delete this.recordingStream;\r\n        }\r\n        for (var i in this.recordingNodes) {\r\n            this.recordingNodes[i].disconnect();\r\n            delete this.recordingNodes[i];\r\n        }\r\n    };\r\n    WAVEInterface.prototype.startPlayback = function (loop, onended) {\r\n        var _this = this;\r\n        if (loop === void 0) { loop = false; }\r\n        return new Promise(function (resolve, reject) {\r\n            var reader = new FileReader();\r\n            reader.readAsArrayBuffer(_this.audioData);\r\n            reader.onloadend = function () {\r\n                WAVEInterface.audioContext.decodeAudioData(reader.result, function (buffer) {\r\n                    var source = WAVEInterface.audioContext.createBufferSource();\r\n                    source.buffer = buffer;\r\n                    source.connect(WAVEInterface.audioContext.destination);\r\n                    source.loop = loop;\r\n                    source.start(0);\r\n                    source.onended = onended;\r\n                    _this.playbackNode = source;\r\n                    resolve(source);\r\n                });\r\n            };\r\n        });\r\n    };\r\n    WAVEInterface.prototype.stopPlayback = function () {\r\n        this.playbackNode.stop();\r\n    };\r\n    WAVEInterface.prototype.reset = function () {\r\n        if (this.playbackNode) {\r\n            this.playbackNode.stop();\r\n            this.playbackNode.disconnect(0);\r\n            delete this.playbackNode;\r\n        }\r\n        this.stopRecording();\r\n        this.buffers = [[], []];\r\n    };\r\n    WAVEInterface.audioContext = new AudioContext();\r\n    WAVEInterface.bufferSize = 2048;\r\n    return WAVEInterface;\r\n}());\r\nexport default WAVEInterface;\r\n"]},"metadata":{},"sourceType":"module"}